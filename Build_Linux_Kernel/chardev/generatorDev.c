#include <linux/init.h> //for __init and __exit
#include <linux/module.h> //loading LKM into kernel
#include <linux/device.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/random.h>

#define DEVICE_NAME     "generDev"
#define CLASS_NAME      "gener"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Hoang Thien Nu");
MODULE_DESCRIPTION("A simple visualization for Linux char driver");
MODULE_VERSION("0.1");

static int majorNumber; //device number 
static char* numberGen; //Number that module generate
static int numberOpens = 0; //Number of time that devide is opened
static struct class* genClass = NULL;
static struct device* genDevice = NULL;

static int     dev_open(struct inode *, struct file *); // Called when device is opened
static int     dev_release(struct inode *, struct file *); // Called when device is closed
static ssize_t dev_read(struct file *, char* , size_t, loff_t *); //Data send form device to user space
//static ssize_t dev_write(struct file *, const char *, size_t, loff_t *); //Data send from user space to device
static struct file_operations fops = 
{
    .open = dev_open,
    .read = dev_read,
    //.write = dev_write,
    .release = dev_release,
};

//LKM init function
static int __init generDev_init(void){
    printk(KERN_INFO "Generator: Initializing the GeneratorDevice LKM\n");

    //allocate a major number for the device
    majorNumber = register_chrdev(0, DEVICE_NAME, &fops);

    if (majorNumber < 0){
        printk(KERN_ALERT "Generator failed to register a major number\n");
        return majorNumber;
    }

    printk(KERN_INFO "Generator: registered correctly with major number %d\n", majorNumber);

    //register the device class
    genClass = class_create(THIS_MODULE, CLASS_NAME);
    if (IS_ERR(genClass)){ //Check for error
        unregister_chrdev(majorNumber, DEVICE_NAME);
        printk(KERN_ALERT "Failed to register device class\n");
        return PTR_ERR(genClass);
    }
    printk(KERN_INFO "Generator: device class registered correctly\n");

    //register the device driver 
    genDevice = device_create(genClass, NULL, MKDEV(majorNumber, 0), NULL, DEVICE_NAME);
    if (IS_ERR(genDevice)){
        class_destroy(genClass);
        unregister_chrdev(majorNumber, DEVICE_NAME);
        printk(KERN_ALERT "Failed to create the device\n");
        return PTR_ERR(genDevice);
    }
    printk(KERN_INFO "Generator: device class created correctly\n");
    return 0;
}

static void __exit generDev_exit(void){
    device_destroy(genClass, MKDEV(majorNumber, 0)); //remove device
    class_unregister(genClass); //unregister device
    class_destroy(genClass);    //remove class 
    unregister_chrdev(majorNumber, DEVICE_NAME); //unregister major number
    printk(KERN_INFO "GeneratorDevice: Goodbye from the LKM!\n");
}

//inodep: pointer to an inode object (linux/fs.h)
//filep: pointer to an file object (linux/fs.h)
static int     dev_open(struct inode *inodep, struct file *filep){
    numberOpens++;
    printk(KERN_INFO "Generator: Device has been open %d time(s)\n", numberOpens);
    return 0;
}

static int     dev_release(struct inode *inodep, struct file *filep){
    printk(KERN_INFO "Generator: Device sucessfully closed\n");
    return 0;
}

//This function is called whenever the device is being read from user space
//data is sent from device to user. 
//Function copy_to_user send numberGen that is number generated by module kernel to user 
//and captures any errors
static ssize_t dev_read(struct file *filep, char* buffer, size_t len, loff_t *offset){
    int error_count = 0;
    //Generate number
    get_random_bytes(numberGen, sizeof(int));

    error_count = copy_to_user(buffer, numberGen, sizeof(int));

    if (error_count == 0){
        printk(KERN_INFO "Generator: Sent a number to the user\n");
        return 0;
    }
    else {
        printk(KERN_INFO "Generator: Failed to sent a number to the user\n");
        return -EFAULT;
    }
}

module_init(generDev_init);
module_exit(generDev_exit);